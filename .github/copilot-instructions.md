# RF-Tools KiCad – AI Coding Guide

- Scope: Suite of KiCad pcbnew Action Plugins + footprint wizards; compatibility spans KiCad 5.1–8.0 per `README.md` and `metadata.json`.
- Layout: Top-level plugin dirs (`round_tracks/`, `taper_fz/`, `trace_solder_expander/`, `tracks_length/`, `trace_clearance/`, `via_fence_generator/`, `rf_tools_wizards/`) plus shared resources/icons and `packaging/` for release artifacts.
- Entry pattern: Each action plugin subclasses `pcbnew.ActionPlugin` with `defaults()` defining name/category/icon/toolbar flag and `Run()` driving wx dialogs + pcbnew ops (see `round_tracks/round_trk.py`, `trace_clearance/trace_clearance.py`, `trace_solder_expander/trace_solder_expander.py`, `via_fence_generator/viafence_action.py`, `tracks_length/trace_length.py`). Keep these signatures; KiCad discovers plugins via the class.
- UI dialogs: wxFormBuilder-generated dialogs live alongside code (`*Dlg.py`, `.fbp` files). Dialog classes are wrapped (e.g., `RoundTrackDlg`, `TraceClearanceDlg`, `SolderExpanderDlg`) and are instantiated in `Run()`; prefer reusing these rather than recreating layouts.
- Config storage: Per-plugin INI files persist window size/last parameters (e.g., `round_tracks/rt_config.ini`, `trace_clearance/tc_config.ini`, `trace_solder_expander/tse_config.ini`, `via_fence_generator/vf_config.ini`). When adding params, update reads/writes consistently and keep defaults reasonable.
- Unit handling: Geometry uses pcbnew internal units; conversions via `pcbnew.ToMM`/`FromMM` are standard. Maintain helper naming (`ToUnits`/`FromUnits`) and avoid mixing raw mm values.
- Version compatibility: Code guards pcbnew API differences with `hasattr` (e.g., `TRACK` vs `PCB_TRACK`, `ZONE_CONTAINER` vs `ZONE`, `EDA_RECT`, wxPoint variants). Do not remove these shims; extend them if adding new KiCad-version-specific behavior.
- Via Fence plugin: Entry at `via_fence_generator/viafence_action.py`, geometry helpers in `viafence.py`, dialogs in `viafence_dialogs.py`; uses `temporary_fix` for older KiCad and de-duplicates vias with clearance-aware checks. Test harness in `via_fence_generator/__main__.py` supports `--runtests`/`--test <name>` using JSON fixtures under `via_fence_generator/tests/`; requires numpy + matplotlib + wx for plotting.
- Other plugins: `trace_clearance` builds keepout zones for selected tracks; handles arcs and multiple pcbnew zone classes. `trace_solder_expander` expands solder mask for selected tracks/pads, with optional discretization on older KiCad. `tracks_length` reports length (and angle) for selected tracks or connected nets from a selected pad. `taper_fz/taper_plugin.py` invokes `SetTaper_Zone` from `taper.py` to build tapers as zones.
- Footprint wizards: `rf_tools_wizards/uw*` modules implement microwave footprint generators; copied into KiCad footprint wizards dir during packaging.
- External deps: Runtime depends on KiCad’s bundled `pcbnew` + `wx`. `via_fence_generator/python-pyclipper/` ships platform-specific pyclipper binaries; keep directory names intact. Test/CLI flow needs numpy/matplotlib in the environment.
- Packaging workflow: `python package.py` copies plugin folders/files into `packaging/` and zips to `rftools.zip` using `packaging/metadata.json` + resources; ensure new plugins are added to `plugins_folders` and resources lists before packaging.
- Installation notes: For manual testing, copy plugin directories and shared files into the KiCad user plugin directory (see KiCad docs link in `README.md`). Icons are resolved relative to each module; keep filenames stable.
- Coding style: Preserve GPL headers, minimal debug logging via `wx.LogMessage`, and helper naming (e.g., `wxLogDebug`, `distance`, `getTrackAngle`). Favor small helper functions over inlining geometry math to ease cross-version maintenance.
- Testing: Only automated tests present are via-fence JSON fixtures executed through `python -m via_fence_generator --runtests`. Update fixtures if algorithm outputs change; `--store` rewrites expected JSON.
- Risks to watch: geometry routines assume integer pcbnew coords; avoid converting to float mid-pipeline. Many algorithms mutate selection; ensure selections are cleared/refreshed (`pcbnew.Refresh()`) when altering workflows. Older KiCad builds may lack certain APIs—feature-gate additions similarly to existing guards.

Use these conventions when extending plugins or adding new ones so they remain KiCad-version friendly, packageable via `package.py`, and compatible with existing dialogs/config files.